/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "Voice.h"
#include "HostParam.h"

// UI header, should be hidden behind a factory
#include <PluginEditor.h>

//==============================================================================
PluginAudioProcessor::PluginAudioProcessor()
{
    addParameter(new HostParam<Param>(osc1fine));
    addParameter(new HostParam<Param>(osc1coarse));

    addParameter(new HostParam<Param>(lfo1freq));
    addParameter(new HostParam<Param>(osc1lfo1depth));

    addParameter(new HostParam<Param>(osc1trngAmount));
    addParameter(new HostParam<Param>(osc1pulsewidth));

    addParameter(new HostParam<Param>(lpCutoff));
    addParameter(new HostParam<Param>(lpResonance));

    addParameter(new HostParam<Param>(envAttack));
    addParameter(new HostParam<Param>(envDecay));
    addParameter(new HostParam<Param>(envSustain));
    addParameter(new HostParam<Param>(envRelease));

    addParameter(new HostParam<Param>(panDir));
}

PluginAudioProcessor::~PluginAudioProcessor()
{
}

//==============================================================================
const String PluginAudioProcessor::getName() const
{
#ifdef JucePlugin_Name
    return JucePlugin_Name;
#else
    // standalone
    return "plugin";
#endif
}

const String PluginAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String PluginAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool PluginAudioProcessor::isInputChannelStereoPair (int index) const
{
    ignoreUnused(index);
    return true;
}

bool PluginAudioProcessor::isOutputChannelStereoPair (int index) const
{
    ignoreUnused(index);
    return true;
}

bool PluginAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool PluginAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool PluginAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double PluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int PluginAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int PluginAudioProcessor::getCurrentProgram()
{
    return 0;
}

void PluginAudioProcessor::setCurrentProgram (int index)
{
    ignoreUnused(index);
}

const String PluginAudioProcessor::getProgramName (int index)
{
    ignoreUnused(index);
    return String();
}

void PluginAudioProcessor::changeProgramName (int index, const String& newName)
{
    ignoreUnused(index,newName);
}

//==============================================================================
void PluginAudioProcessor::prepareToPlay (double sRate, int samplesPerBlock)
{
    ignoreUnused(samplesPerBlock);
    synth.setCurrentPlaybackSampleRate(sRate);
    synth.clearVoices();
    for (int i = 8; --i >= 0;)
    {
        synth.addVoice(new Voice(*this, samplesPerBlock));
    }
    synth.clearSounds();
    synth.addSound(new Sound());
}

void PluginAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void PluginAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    updateHostInfo();

    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

    runSeq(buffer, midiMessages);

    // pass these messages to the keyboard state so that it can update the component
    // to show on-screen which keys are being pressed on the physical midi keyboard.
    // This call will also add midi messages to the buffer which were generated by
    // the mouse-clicking on the on-screen keyboard.
    keyboardState.processNextMidiBuffer(midiMessages, 0, buffer.getNumSamples(), true);

    // and now get the synth to process the midi events and generate its output.
    synth.renderNextBlock(buffer, midiMessages, 0, buffer.getNumSamples());
}

void PluginAudioProcessor::updateHostInfo()
{
    // currentPositionInfo used for getting the bpm.
    if (AudioPlayHead* playHead = getPlayHead())
    {
        if (playHead->getCurrentPosition (positionInfo[getAudioIndex()])) {
            positionIndex.exchange(getGUIIndex());
            return;
        }
    }
    positionInfo[getAudioIndex()].resetToDefault();
}

//==============================================================================
/*
* I actually wanted to create a extra class or object for the sequencer but did not succeed in doing so.
* That's why the sequencer call is here for now.
*/
void PluginAudioProcessor::runSeq(AudioSampleBuffer& buffer, MidiBuffer & midiMessages)
{
    // get GUI params
    currMidiSeq[0] = static_cast<int>(SynthParams::seqStep1.get());
    currMidiSeq[1] = static_cast<int>(SynthParams::seqStep2.get());
    currMidiSeq[2] = static_cast<int>(SynthParams::seqStep3.get());
    currMidiSeq[3] = static_cast<int>(SynthParams::seqStep4.get());
    currMidiSeq[4] = static_cast<int>(SynthParams::seqStep5.get());
    currMidiSeq[5] = static_cast<int>(SynthParams::seqStep6.get());
    currMidiSeq[6] = static_cast<int>(SynthParams::seqStep7.get());
    currMidiSeq[7] = static_cast<int>(SynthParams::seqStep8.get());
    seqMode = static_cast<int>(SynthParams::seqMode.get());
    seqNumSteps = static_cast<int>(SynthParams::seqNumSteps.get());
    seqStepSpeed = SynthParams::seqStepSpeed.get();
    seqNoteLength = jmin(SynthParams::seqStepLength.get(), seqStepSpeed);

    // if any note changed then send noteOff message to that note
    midiNoteChanged(midiMessages);
    prevMidiSeq = currMidiSeq;

    switch (seqMode)
    {
    case 1:
        seqNoHostSync(buffer, midiMessages);
        break;
    case 2:
        seqHostSync(buffer, midiMessages);
        break;
    default:
        stopSeq(midiMessages);
        break;
    }
}

/*
* Called while stepSequencer is not synced with host (seqMode == 1).
*/
void PluginAudioProcessor::seqNoHostSync(AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // if is playing a note then prepare sending midi noteOff message
    if (seqIsPlaying)
    {
        // if midi noteOff message fits into current buffer
        if (noteOffSample < buffer.getNumSamples() - 1)
        {
            // send midimessage into midibuffer
            MidiMessage m = MidiMessage::noteOff(1, currMidiSeq[seqNote]);
            midiMessages.addEvent(m, noteOffSample);
            seqIsPlaying = false;
        }
        else
        {
            nextPlaySample -= buffer.getNumSamples() - 1;
            noteOffSample -= buffer.getNumSamples() - 1;
        }
    }

    // if is not playing a note then prepare sending midi noteOn message
    if (!seqIsPlaying)
    {
        // if midi noteOn message fits into current buffer
        if (nextPlaySample < buffer.getNumSamples()-1)
        {
            // set Note to play
            seqNote++;
            seqNote = seqNote%seqNumSteps;

            // emphasis on step 1
            float seqVelocity = 0.45f;
            if (seqNote == 0)
            {
                seqVelocity = 0.85f;
            }

            // send midimessage into midibuffer
            if (currMidiSeq[seqNote] != -1)
            {
                MidiMessage m = MidiMessage::noteOn(1, currMidiSeq[seqNote], seqVelocity);
                midiMessages.addEvent(m, nextPlaySample);
                seqIsPlaying = true;
            }

            // calculate noteOffSample and nextPlaySample 
            double quarterSec = 60.0 / positionInfo[getAudioIndex()].bpm;
            noteOffSample = static_cast<int>(quarterSec * seqNoteLength * getSampleRate());
            nextPlaySample = static_cast<int>(quarterSec * seqStepSpeed * getSampleRate());
        }
        else
        {
            nextPlaySample -= buffer.getNumSamples() - 1;
            noteOffSample -= buffer.getNumSamples() - 1;
        }
    }
}

/*
* Called while stepSequencer is synced with host (seqMode == 2).
*/
void PluginAudioProcessor::seqHostSync(AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    ignoreUnused(buffer);
    AudioPlayHead::CurrentPositionInfo hostPlayHead = positionInfo[getAudioIndex()];
    double currPos = hostPlayHead.ppqPosition;

    if (hostPlayHead.isPlaying)
    {
        // time for creating noteOn event
        if (currPos >= seqNextStep)
        {
            // stop note if could not stop before playing next note (important for seqNoteLength == seqStepSpeed)
            if (seqIsPlaying)
            {
                if (currMidiSeq[seqNote] != -1)
                {
                    MidiMessage m = MidiMessage::noteOff(1, currMidiSeq[seqNote]);
                    midiMessages.addEvent(m, 0);
                    seqIsPlaying = false;
                }
            }

            // send midimessage into midibuffer
            if (!seqIsPlaying)
            {
                // calculate the right note to play
                seqNote = jmax(0, static_cast<int>(currPos / static_cast<double>(seqStepSpeed)) % seqNumSteps);
                seqNote = jmin(seqNote, seqNumSteps - 1);

                if (currMidiSeq[seqNote] != -1)
                {
                    // emphasis on step 1
                    float seqVelocity = 0.45f;
                    if (seqNote == 0)
                    {
                        seqVelocity = 0.85f;
                    }

                    MidiMessage m = MidiMessage::noteOn(1, currMidiSeq[seqNote], seqVelocity);
                    midiMessages.addEvent(m, 0);
                    stopNoteTime = currPos + seqNoteLength;
                    seqIsPlaying = true;
                }
            }
        }

        // time for creating corresponding noteOff event to end each step
        if (currPos >= stopNoteTime)
        {
            // send midimessage into midibuffer
            if (seqIsPlaying)
            {
                if (currMidiSeq[seqNote] != -1)
                {
                    MidiMessage m = MidiMessage::noteOff(1, currMidiSeq[seqNote]);
                    midiMessages.addEvent(m, 0);
                    seqIsPlaying = false;
                }
            }
        }
    }
    else
    {
        // if host is not playing then stop sequencer and reset variables
        stopSeq(midiMessages);
    }
    // recalculate next step position in host sync mode
    seqNextStep = currPos + abs(remainder(currPos, static_cast<double>(seqStepSpeed)));
}

/*
* If any seqStepNote changed then send noteOff message for the old note.
* Better if there was a own seq class so that each slider would call 
* a single noteOff function before changing values.
*/
void PluginAudioProcessor::midiNoteChanged(MidiBuffer & midiMessages)
{
    for (int i = 0; i < seqNumSteps; ++i)
    {
        if (prevMidiSeq[i] != currMidiSeq[i])
        {
            MidiMessage m = MidiMessage::noteOff(1, prevMidiSeq[i]);
            midiMessages.addEvent(m, 0);
        }
    }
}

/*
* Stop stepSequencer and reset not GUI variables.
*/
void PluginAudioProcessor::stopSeq(MidiBuffer& midiMessages)
{
    // stop and reset only if not already stopped
    if (seqNote != -1)
    {
        seqNextStep = 0.0;
        stopNoteTime = 0.0;
        seqIsPlaying = false;
        seqNote = -1;
        nextPlaySample = 0;
        noteOffSample = 0;

        // stop all midimessages from sequencer
        MidiMessage m = MidiMessage::allNotesOff(1);
        midiMessages.addEvent(m, 0);
    }
}
//==============================================================================
bool PluginAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* PluginAudioProcessor::createEditor()
{
    return new PluginAudioProcessorEditor (*this);
}

//==============================================================================
void PluginAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    ignoreUnused(destData);
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void PluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    ignoreUnused(data,sizeInBytes);
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new PluginAudioProcessor();
}
